# **The best solution to the task**

Здесь собраны мои наиболее удачные решения задач, которые возможно будут полезны.


## **Pallindrom**

Задача: проверить, является ли слово паллиндромом, то есть его перевернутый вид должен быть идентичен изначальному, выдать true усли это так и false если нет.

```JavaScript
const palindrom = str => str == str.toLowerCase().split('').reverse().join('');
```

Здесь мы используем стрелочную функцию и оператор строгого сравнения, где слева исходная строка, а справа мы приводим все символы к нижнему регистру, после этого преобразуем строку в массив строк, после этого с помощью метода __```reverse```__ переворачиваем строку, после этого сново объединяем символы с помощью метода __```join```__, результат сравнения и есть наш ответ. 
P.S. Очень люблю решения в одну строку :)

## **Unique array values**

Задача: оставить в массиве только уникальные значения и вывести их в новом массиве.

```JavaScript
const unikFunc = [...new Set(unik)];
```

Здесь мы используем структуру данных __```Set```__ которая хранит только уникальные значения массива, далее с помощью метода __```spread```__ преобразуем структуру данных в массив.

## **Comparing two arrays**

Задача: сравнить два массива, если они равны, выдать true, если не равны false, если хоть один аргумент не является массивом, выдать что это не массив.__(Массивы не содержат элементы которые сами являются массивами, так же игнорируется присвоение по ссылке(задача в посимвольном сравнении, то что массивы равны только если они присвоены по одной и той же ссылке игнорируется))__

```JavaScript
function arrIdentical (a, b) {
  if (!(Array.isArray(a) || Array.isArray(b))) return "this is not an array";
  
  let i = a.length;
  
  if (i != b.length) return false;
  while (i--) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
```

Здесь с помощь метода __```Array.isArray()```__ мы определяем, являетются ли оба аргумента массивами, если хоть один не являтеся, выдаем "this is not an array". Позже мы сравниваем длины масивов с помощью метода __```length```__, если длины не равны, значит и массивы не равны, выдаем false. Далее с помощью цикла __```while```__ мы сравниваем элементы массивов посимвольно, если все символы строго равны, значит массивы равны.

## **Number to digit tiers**

Задача: создать функцию, которая принимает число и возвращает массив строк, содержащих число, отрезанное на каждой цифре, пример:

2017 должен вернуться ["2", "20", "201", "2017"]

```JavaScript
function createArrayOfTiers(num) {
    let result = '';
    return [...num + ''].map(value => {
      return result += value;
    });
};
```

Здесь мы сначала заводим счетчик result и присваиваем ему пустую строку. Далее мы разворачиваем аргумент num в массиве с помощью оператора __```spread```__ (оператор __```spread```__ развернутый в квадратных скобках приводит строку к массиву строк), но здесь аргумент число, поэтому, мы прибавляем к аргументу пустую строку что бы привести его к строке и получаем массив строк. Далее с помощью метода __```map```__ мы итерируем каждое значение массива и прибавляем его к счетчику(сложение строк) и результат каждой итерации это новое значение нового массива.

## **Is the number divisible by 3**

Задача: дана строка из положительного целого числа и нужно определить, делится оно на 3 или нет.

```JavaScript
let divisibleByThree = (str) => (str.split('').map(parseFloat).reduce((a, b) => a + b)) % 3 ? false : true;
```
Здесь сначала с помощью метода __```split```__ мы приводим строку к массиву строк, после методом __```map(parseFloat)```__ мы приводим каждое значение к числу, после мы суммируем все значения с помощью метода __```reduce```__ и после мы проверяем, делится оно на 3 без остатка или нет, если остаток есть, значит не делится, выдаем false, если остатка нет то true.

## **Сhanging a line**

Задача: дана строка, в строке некоторые гласные заменены цифрами (a=0, e=1, i=2, o=3, u=4), так же посреди строки есть два слова trex и raptor, их необходимо не учитывать, нужно расшифровать строку и написать ее с загдавной буквы, кроме того, если в строке встречается I (в значении "я"), ее необходимо написать с большой буквы, если i это часть слова (например "Dinosaurs"), то необходимо оставить ее маленькой, в конце предложения должна быть точка.

```JavaScript
function nonsense(str) {
  let resStr = str.toLowerCase()
              .replace(/0|1|2|3|4/g, e => 'aeiou'[e])
              .replace(/trex|raptor/g, '')
              .replace(/^.| i /g, s => s.toUpperCase()) + (str.slice(-1) === '.' ? '' : '.');
  
  return resStr[0].toUpperCase() + resStr.substring(1);
}
```
Сначала мы приводим все символы к нижнему регистру с помощью метода __```toLowerCase```__, далее открытие недели(я в восторге от этого метода), методом __```replace```__ заменяем сначала цифры на символы, после слова trex|raptor на пустую строку и после если перед I ничего нет, то с помощью метда __```toUpperCase```__ приводим к верхнему регистру, далее, с помощью метода __```slice```__ с флагом -1 прибавляем точку если ее нет, и если она есть то ничего не прибавляем. Далее в новой переменной мы приводим первый символ к верхнему регистру(отсчет начинается с 0), далее прибавляем оставшуюся строку начиная со второго символа(индекс 1) с помощью метода __```substring```__.

## **Consecutive Differences**

Задача: дан массив целых чисел, необходимо найти положительную разность между каждой последовательной парой чисел и поместите ее в новый массив разностей. Затем найти разность между последовательными парами в этом новом массиве и повторить, пока массив не будет иметь длину 1. Затем вернуть единственное значение.

Список будет содержать только целые числа и не будет пустым.

```JavaScript
const differences = a => {
    while (a.length > 1) {
        a = a.slice(1).map((e, i) => Math.abs(a[i] - e))
    };
    return +a
};
```
Здесь мы используем цикл __```while```__, где условием выполнение цикла является длинна массива больше 1. На каждой итерации с помощью метода __```slice```__ с флагом 1 мы удаляем первый элемент, далее с помощью метода __```map```__ мы получаем разность первого элемента исходного массива __```a[i]```__ и первого элемента массива с удаленным первым элементом(второй элемент исходного массива), разность мы получаем в абсолютных значениях с помощью метода __```Math.abs()```__, итоговое значение это массив который мы приводим к строке с помощью унарного плюса. 

```JavaScript
a.slice(1).map((e, i) => Math.abs(a[i] + e))
```
Эту часть так же можно использовать для получения абсолютной суммы последовательных элементов массива, или просто последовательной суммы элементов не используя Math.abs.

## **adding strings**
Задача: дан массив строк, ```["яблоко","груша","ананас"]```, необходимо просуммировать все строки в массиве, что бы получился новый массив вида ```["яблоко","яблокогруша","яблокогрушаананас"]```.

```JavaScript
function spacey(array){
  let string = ''
  return array.map( (e) => string += e )
}
```

Здесь мы сначла объявляем пустую строку, после этого с помощью метода __```map```__ и оператора += прибавляем к каждому значению новое значение, не удаляя старое.

## **Return a string's even characters**

Задача: написать функцию, которая возвращает последовательность всех четных символов из строки. Если строка меньше двух символов или длиннее 100 символов, функция должна возвращать "недопустимую строку".

```JavaScript
const evenChars = (string) => string.length <= 1 || string.length > 100 ? "invalid string" : string.split("").filter((a, i) => i % 2 === 0 ? '' : a);
```

Здесь мы сначала проверяем допустимость строки, после с помощью метода __```split```__ приводим строку к массиву, после с помощью метода __```filter```__ проверяем на четность индекс, и возвращаем только четные индексы.

